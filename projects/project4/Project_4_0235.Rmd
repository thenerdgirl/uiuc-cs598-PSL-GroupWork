---
title: "Project 4: Movie Recommender System"
subtitle: "CS598: Practical Statistical Learning"
author: 
 - name: Naomi Bhagat - nbhagat3
 - name: Michael Miller - msmille3
 - name: Joe May - jemay3
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    theme: readable
    toc: yes
urlcolor: cyan
---

# Assignment Data
Program: MCS-DS  
Team contributions:

| Person         | Contribution |
|----------      |----------|
| Naomi Bhagat   | Application |
| Michael Miller | System 1 |
| Joe May        | System 2  |

Assignment URL: [campuswire post](https://liangfgithub.github.io/Proj/F23_Proj4.html)

# Setup
Install packages and set random seed.
```{r setup, eval=TRUE, warning=FALSE, message=FALSE}
# add required packages
packages = c('tidyverse')

# if packages don't exist, install. Then call library on them
for (package in packages) {
  if (!requireNamespace(package, quietly=TRUE)) {
    install.packages(package)
  }
  library(package, character.only=TRUE)
}

# set seed
set.seed(235)
```

Download and preprocess data. 
```{r preprocess, eval = TRUE}
# download and preprocses raw movie data
# note that this code is from example code from this class 
# https://liangfgithub.github.io/Rcode_W13_Movie_EDA.nb.html

source_url = "https://liangfgithub.github.io/MovieData/"

ratings = read.csv(paste0(source_url, 'ratings.dat?raw=true'), 
                   sep = ':',
                   colClasses = c('integer', 'NULL'), 
                   header = FALSE)

colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')

# load movies. Same source
movies = readLines(paste0(source_url, 'movies.dat?raw=true'))
movies = strsplit(movies, split = "::", fixed = TRUE, useBytes = TRUE)
movies = matrix(unlist(movies), ncol = 3, byrow = TRUE)
movies = data.frame(movies, stringsAsFactors = FALSE)
colnames(movies) = c('MovieID', 'Title', 'Genres')
movies$MovieID = as.integer(movies$MovieID)

# convert accented characters
movies$Title = iconv(movies$Title, "latin1", "UTF-8")

# extract year
movies$Year = as.numeric(unlist(
  lapply(movies$Title, function(x) substr(x, nchar(x)-4, nchar(x)-1))))

# 
users = read.csv(paste0(source_url, 'users.dat?raw=true'),
                 sep = ':', header = FALSE)
users = users[, -c(2,4,6,8)] # skip columns
colnames(users) = c('UserID', 'Gender', 'Age', 'Occupation', 'Zip-code')
```

# System I: Recommendation Based on Genres

We propose the following genre-based recommendation system. A description of the system is provided first, with implementation in `R` below. This section of the report generates a .csv file that will be used directly by the application to make recommendations.

## Description

In order to provide a variety of recommendations, we suggest movies from three separate categories. The implementation below generates parameterized number of recommendations from each category, then randomly samples the set for the final recommendations. 

### All Time Favorites
This category is defined as movies with the largest total number of 5-star reviews. In theory, these movies have been enjoyed by the largest number of people. It is worth noting that this category inherently favors older movies, as they have had more time to accumulate reviews. In addition, this category does not take into account any negative reviews, so theoretically a movie with a large number of both positive and negative reviews could still make this category. Regardless, these movies should be highly significant for the chosen genre.  

### Popular Movies
Here, we consider the average review score of movies. This means that the age of a movie does not necessarily give it an advantage. To avoid edge cases where only a few reviewers may bias scores, we filter out movies with under 100 reviews. These are well-liked movies that the user may enjoy. 

### Hidden Gems
Finally, we consider movies with the highest average rating, but with only between 5 and 100 reviews. With so few reviews, these movies are vulnerable to being biased by only a few reviewers. We choose to include a small nubmer of these movies because:  
1. It may expose the user to good movies that are not well known.  
2. By giving these movies more exposure, they will ultimately receive more reviews and improve the overall quality of our application's recommendations.  

## Limitations
This algorithm is implemented with a fixed set of reviews. Ideally, in a real world setting we would randomize the suggestions for each user (or possibly for each visit to the application). In addition, we would periodically regenerate the overall list of recommendations to account for new reviews coming in from users. Finally, it would be useful to track a user's selections. For example, if a user selects a movie from the recommendation, we could replace it with a new recommendation. 

# Implementation 
```{r system1, eval = TRUE}
# define the quantity of movies for each genre for each type 
n_all_time_fav = 50
n_popular = 40
n_hidden = 10
n_total_recs = 10

# define params for establishing popular movies vs hidden gems
min_reviews_popular = 100
min_reviews_hidden = 5

# first, unpack and duplicate genres so that each movie-genre combo is one row
movie_genres = movies %>% 
  mutate(Genres = strsplit(Genres, '\\|')) %>%
  rename(Genre = Genres) %>%
  unnest(Genre)

# get number of 5 star reviews for calculating all time favorites
perfect_reviews = ratings %>%
  filter(Rating == 5) %>%
  group_by(MovieID) %>%
  summarize(PerfectReviews = n())

# get average review for popular movies
review_percent_popular = ratings %>%
  group_by(MovieID) %>%
  filter(n() >= min_reviews_popular) %>%
  summarize(AvgRating = mean(Rating))
  
# get average review for hidden gems
review_percent_hidden = ratings %>%
  group_by(MovieID) %>%
  filter(n() >= min_reviews_hidden) %>%
  filter(n() < min_reviews_popular) %>%
  summarize(AvgRating = mean(Rating))

# join perfect reviews with movie genres, take top n to get all time favorites
all_time_favorites = movie_genres %>%
  inner_join(perfect_reviews, by="MovieID") %>%
  arrange(desc(PerfectReviews)) %>%
  group_by(Genre) %>%
  slice_head(n=n_all_time_fav)

all_time_favorites['Rationale'] = 'All time favorite'

# we will track our final set of movies as out
out = all_time_favorites[c('MovieID', 'Title', 'Genre', 'Year', 'Rationale')]

# join average review with movie genres, take top n to get popular movies
# note we are excluding any movie that might already be all time favorites
popular = movie_genres %>%
  anti_join(out, by="MovieID") %>%
  inner_join(review_percent_popular, by="MovieID") %>%
  arrange(desc(AvgRating)) %>%
  group_by(Genre) %>%
  slice_head(n=n_popular)
popular['Rationale'] = 'Popular'

out = bind_rows(out, popular[c('MovieID', 'Title', 'Genre', 'Year', 'Rationale')])

# join average hidden gem reviews with movie genres, take top n to get hiden gems
# note we are excluding any movies already chosen
hidden = movie_genres %>%
  anti_join(out, by="MovieID") %>%
  inner_join(review_percent_hidden, by="MovieID") %>%
  arrange(desc(AvgRating)) %>%
  group_by(Genre) %>%
  slice_head(n=n_hidden)
hidden['Rationale'] = 'Hidden gem'

out = bind_rows(out, hidden[c('MovieID', 'Title', 'Genre', 'Year', 'Rationale')])

# next, we randomly sample n_total_rec films from out for each genre, and we save these for use in the app
to_csv = out %>%
  arrange(sample(n())) %>%
  group_by(Genre) %>%
  slice_head(n=n_total_recs)
  
write_csv(to_csv, 'genre_recommendations.csv')
```

# Sample Code (MOVE ME TO APPLICATION)
```{r system1_sample_app_usage, eval = TRUE}

get_genre_recommendations = function(movies, genre) {
  # given a movies dataframe (in format generated by section above)
  # and a genre string, return recommendations as a tibble 
  # requires tidyverse
  return(movies %>% filter(Genre == genre))
}

suppressMessages({
  rec_tibble = read_csv('genre_recommendations.csv')
})

genres = unique(rec_tibble$Genre)
genre = genres[11]

recs = get_genre_recommendations(rec_tibble, genre)

cat('Recommendation for:', genre, '\n')
print(recs)
```


# System II: Recommendation Based on IBCF

```{r system2, eval = TRUE}
```

